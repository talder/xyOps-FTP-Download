{
	"type": "xypdf",
	"description": "xyOps Portable Data Object",
	"version": "1.0",
	"xyops": "1.0.3",
	"items": [
		{
			"type": "plugin",
			"data": {
				"id": "ftp1download001",
				"title": "FTP Download",
				"enabled": true,
				"type": "event",
				"command": "pwsh",
				"scriptFile": "ftp.ps1",
				"groups": [],
				"format": "",
				"params": [
					{
						"id": "protocol",
						"title": "Protocol",
						"type": "select",
						"caption": "Transfer protocol to use",
						"locked": false,
						"value": "FTP — Plain FTP [ftp], FTPS — FTP over TLS/SSL [ftps], SFTP — SSH File Transfer [sftp]"
					},
					{
						"id": "host",
						"title": "Host",
						"type": "text",
						"caption": "Server hostname or IP address. Overrides FTP_HOST secret.",
						"locked": false,
						"value": "",
						"variant": "text",
						"required": false
					},
					{
						"id": "port",
						"title": "Port",
						"type": "text",
						"caption": "Server port. Leave empty for auto-detect (21 for FTP/FTPS Explicit, 990 for FTPS Implicit, 22 for SFTP). Overrides FTP_PORT secret.",
						"locked": false,
						"value": "",
						"variant": "text",
						"required": false
					},
					{
						"id": "username",
						"title": "Username",
						"type": "text",
						"caption": "FTP/SFTP username. Overrides FTP_USERNAME secret.",
						"locked": false,
						"value": "",
						"variant": "text",
						"required": false
					},
					{
						"id": "password",
						"title": "Password",
						"type": "text",
						"caption": "FTP/SFTP password. Overrides FTP_PASSWORD secret.",
						"locked": false,
						"value": "",
						"variant": "text",
						"required": false
					},
					{
						"id": "ftpsMode",
						"title": "FTPS Mode",
						"type": "select",
						"caption": "TLS mode for FTPS connections (only applies when Protocol is FTPS)",
						"locked": false,
						"value": "Explicit — STARTTLS on port 21 [explicit], Implicit — Direct TLS on port 990 [implicit]"
					},
					{
						"id": "sshKeyPath",
						"title": "SSH Key Path",
						"type": "text",
						"caption": "Path to SSH private key file (SFTP only). Supports RSA, ED25519, ECDSA, DSA. Overrides FTP_SSH_KEY_PATH secret.",
						"locked": false,
						"value": "",
						"variant": "text",
						"required": false
					},
					{
						"id": "sshKeyPassphrase",
						"title": "SSH Key Passphrase",
						"type": "text",
						"caption": "Passphrase for encrypted SSH private key (SFTP only). Overrides FTP_SSH_KEY_PASSPHRASE secret.",
						"locked": false,
						"value": "",
						"variant": "text",
						"required": false
					},
					{
						"id": "remotePath",
						"title": "Remote Path",
						"type": "text",
						"caption": "File or folder path to download from remote server. Supports glob patterns (e.g., /logs/*.log)",
						"locked": false,
						"value": "",
						"variant": "text",
						"required": true
					},
					{
						"id": "localPath",
						"title": "Local Path",
						"type": "text",
						"caption": "Local directory to save downloaded files. Leave empty to save in plugin working directory (CWD).",
						"locked": false,
						"value": "",
						"variant": "text",
						"required": false
					},
					{
						"id": "downloadMode",
						"title": "Download Mode",
						"type": "select",
						"caption": "What to download from the remote server",
						"locked": false,
						"value": "Single file [file], Folder (recursive) [folder], Pattern match [pattern]"
					},
					{
						"id": "ifFileExists",
						"title": "If File Exists Locally",
						"type": "select",
						"caption": "What to do when a file already exists locally",
						"locked": false,
						"value": "Overwrite [overwrite], Skip [skip], Error [error], Rename with timestamp [rename]"
					},
					{
						"id": "deleteAfterDownload",
						"title": "Delete After Download",
						"type": "checkbox",
						"caption": "Delete files from remote server after successful download",
						"locked": false,
						"value": false
					},
					{
						"id": "createLocalDirs",
						"title": "Create Local Directories",
						"type": "checkbox",
						"caption": "Automatically create local directories if they don't exist",
						"locked": false,
						"value": true
					},
					{
						"id": "passiveMode",
						"title": "Passive Mode",
						"type": "checkbox",
						"caption": "Use passive mode for FTP/FTPS connections (recommended for most firewalls and NAT setups)",
						"locked": false,
						"value": true
					}
				],
				"notes": "",
				"icon": "download",
				"uid": "",
				"gid": "",
				"script": "#requires -Version 7.0\n# Copyright (c) 2026 Tim Alderweireldt. All rights reserved.\n<#!\nxyOps FTP Download Event Plugin (PowerShell 7)\nDownload files from remote servers via FTP, FTPS (Explicit/Implicit), or SFTP.\n\nProtocols:\n- FTP  : Plain FTP via .NET System.Net.FtpWebRequest (port 21)\n- FTPS : FTP over TLS — Explicit (STARTTLS, port 21) via .NET, Implicit (port 990) via TcpClient+SslStream\n- SFTP : SSH File Transfer Protocol via Posh-SSH module (port 22)\n\nI/O contract:\n- Read one JSON object from STDIN (job), write progress/messages as JSON lines of the\n  form: { \"xy\": 1, ... } to STDOUT.\n- On success, emit: { \"xy\": 1, \"code\": 0, \"data\": <result>, \"files\": [...], \"description\": \"...\" }\n- On error, emit:   { \"xy\": 1, \"code\": <nonzero>, \"description\": \"...\" } and exit 1.\n\nTest locally:\n  pwsh -NoProfile -ExecutionPolicy Bypass -File .\\ftp.ps1 < job.json\n#>\n\nSet-StrictMode -Version Latest\n$ErrorActionPreference = 'Stop'\n\n#region xyOps Output Helpers\n\nfunction Write-XY {\n  param([hashtable]$Object)\n  $payload = [ordered]@{ xy = 1 }\n  foreach ($k in $Object.Keys) { $payload[$k] = $Object[$k] }\n  [Console]::Out.WriteLine(($payload | ConvertTo-Json -Depth 20 -Compress))\n  [Console]::Out.Flush()\n}\n\nfunction Write-XYProgress {\n  param([double]$Value, [string]$Status)\n  $o = @{ progress = [math]::Round($Value, 4) }\n  if ($Status) { $o.status = $Status }\n  Write-XY $o\n}\n\nfunction Write-XYSuccess {\n  param($Data, [string]$Description, [array]$Files = @())\n  $o = @{ code = 0; data = $Data }\n  if ($Description) { $o.description = $Description }\n  if ($Files.Count -gt 0) { $o.files = $Files }\n  Write-XY $o\n}\n\nfunction Write-XYError {\n  param([int]$Code, [string]$Description)\n  Write-XY @{ code = $Code; description = $Description }\n}\n\nfunction Read-JobFromStdin {\n  $raw = [Console]::In.ReadToEnd()\n  if ([string]::IsNullOrWhiteSpace($raw)) { throw 'No job JSON received on STDIN' }\n  return $raw | ConvertFrom-Json -ErrorAction Stop\n}\n\nfunction Get-Param {\n  param($Params, [string]$Name, $Default = $null)\n  if ($Params.PSObject.Properties.Name -contains $Name) { return $Params.$Name }\n  return $Default\n}\n\n#endregion\n\n#region Module Installer\n\nfunction Install-RequiredModules {\n  param([string]$Protocol)\n\n  if ($Protocol -ne 'sftp') { return }\n\n  if (-not (Get-Module -ListAvailable -Name 'Posh-SSH')) {\n    Write-XYProgress 0.05 'Installing Posh-SSH module (first-time SFTP setup)...'\n    try {\n      Install-Module -Name 'Posh-SSH' -Scope CurrentUser -Force -AllowClobber -SkipPublisherCheck\n      Write-XYProgress 0.08 'Posh-SSH module installed successfully'\n    }\n    catch {\n      throw (\"Failed to install Posh-SSH module. Install manually: Install-Module -Name Posh-SSH -Scope CurrentUser -Force`n\" +\n             \"Error: $($_.Exception.Message)\")\n    }\n  }\n\n  Import-Module Posh-SSH -ErrorAction Stop\n}\n\n#endregion\n\n#region Error Handling\n\nfunction Format-TransferError {\n  param(\n    [System.Management.Automation.ErrorRecord]$ErrorRecord,\n    [string]$Phase,\n    [string]$Protocol\n  )\n\n  $msg = $ErrorRecord.Exception.Message\n  $innerMsg = if ($ErrorRecord.Exception.InnerException) { $ErrorRecord.Exception.InnerException.Message } else { '' }\n  $fullMsg = if ($innerMsg) { \"$msg — $innerMsg\" } else { $msg }\n\n  $category = 'Unknown'\n  $suggestion = ''\n\n  switch -Regex ($fullMsg) {\n    'No such host|DNS|name.*resolution|could not resolve' {\n      $category = 'Connection — DNS Resolution'\n      $suggestion = 'Verify the hostname is correct and DNS is reachable'\n      break\n    }\n    'actively refused|connection refused|ECONNREFUSED' {\n      $category = 'Connection — Refused'\n      $suggestion = \"Verify the server is running and listening on the correct port for $Protocol\"\n      break\n    }\n    'timed? ?out|ETIMEDOUT' {\n      $category = 'Connection — Timeout'\n      $suggestion = 'Check firewall rules and network connectivity'\n      break\n    }\n    'unreachable|EHOSTUNREACH|ENETUNREACH' {\n      $category = 'Connection — Unreachable'\n      $suggestion = 'Verify network connectivity and routing to the server'\n      break\n    }\n    '530|not log|login.*fail|auth.*fail|invalid.*credential|access denied.*login|permission denied.*publickey' {\n      $category = 'Authentication — Failed'\n      $suggestion = 'Verify username/password or SSH key. Check if the account is active and not locked.'\n      break\n    }\n    'key.*invalid|key.*not.*found|private.*key|bad.*key|key.*format' {\n      $category = 'Authentication — SSH Key Error'\n      $suggestion = 'Verify the SSH key file exists, is readable, and in the correct format (RSA/ED25519/ECDSA/DSA)'\n      break\n    }\n    'passphrase|decrypt.*key' {\n      $category = 'Authentication — Key Passphrase'\n      $suggestion = 'The SSH key is encrypted. Provide the correct passphrase via parameter or FTP_SSH_KEY_PASSPHRASE secret.'\n      break\n    }\n    '550.*permission|553|access.*denied|permission.*denied|not.*authorized' {\n      $category = 'Permission — Access Denied'\n      $suggestion = 'The user does not have read permission on the remote path. Check directory permissions on the server.'\n      break\n    }\n    '550.*no such|550.*not found|no such file|directory.*not.*exist' {\n      $category = 'Permission — Path Not Found'\n      $suggestion = 'The remote path does not exist. Verify the path is correct.'\n      break\n    }\n    '552|disk.*full|no space|quota.*exceeded' {\n      $category = 'Transfer — Disk Full'\n      $suggestion = 'The local disk has insufficient space'\n      break\n    }\n    '451|transfer.*abort|download.*fail|read.*fail' {\n      $category = 'Transfer — Failed'\n      $suggestion = 'The file transfer was interrupted. Check server logs and retry.'\n      break\n    }\n    'SSL|TLS|certificate|handshake|secure.*channel' {\n      $category = 'Protocol — TLS/SSL Error'\n      $suggestion = \"Check TLS configuration. For FTPS, verify the server supports the selected mode (Explicit/Implicit).\"\n      break\n    }\n    'STARTTLS|AUTH TLS' {\n      $category = 'Protocol — STARTTLS Failed'\n      $suggestion = 'The server does not support FTPS Explicit (STARTTLS). Try Implicit mode or plain FTP.'\n      break\n    }\n  }\n\n  if ($category -eq 'Unknown') {\n    $category = \"$Phase — Error\"\n    $suggestion = 'Check the error details and server configuration'\n  }\n\n  Write-XY @{ table = @{\n    title = 'Error Details'\n    header = @('Property', 'Value')\n    rows = @(\n      @('Category', $category),\n      @('Phase', $Phase),\n      @('Protocol', $Protocol.ToUpper()),\n      @('Details', $fullMsg),\n      @('Suggestion', $suggestion)\n    )\n    caption = ''\n  } }\n\n  return \"${category}: $fullMsg\"\n}\n\n#endregion\n\n#region FTP/FTPS Explicit Operations (.NET FtpWebRequest)\n\nfunction New-FTPRequest {\n  param(\n    [string]$Url,\n    [string]$Method,\n    [System.Net.NetworkCredential]$Credential,\n    [bool]$EnableSsl,\n    [bool]$PassiveMode\n  )\n\n  if ($EnableSsl) {\n    [System.Net.ServicePointManager]::ServerCertificateValidationCallback = { param($s, $c, $ch, $e) $true }\n  }\n\n  $request = [System.Net.FtpWebRequest]::Create($Url)\n  $request.Method = $Method\n  $request.Credentials = $Credential\n  $request.EnableSsl = $EnableSsl\n  $request.UsePassive = $PassiveMode\n  $request.UseBinary = $true\n  $request.KeepAlive = $false\n\n  return $request\n}\n\nfunction Get-FTPBaseUrl {\n  param([string]$HostName, [int]$Port)\n  return \"ftp://${HostName}:${Port}\"\n}\n\nfunction Get-FTPFileList {\n  param(\n    [string]$BaseUrl,\n    [string]$RemotePath,\n    [System.Net.NetworkCredential]$Credential,\n    [bool]$EnableSsl,\n    [bool]$PassiveMode,\n    [bool]$Recursive\n  )\n\n  $files = [System.Collections.ArrayList]::new()\n  $url = \"$BaseUrl/$($RemotePath.TrimStart('/'))\"\n\n  try {\n    $request = New-FTPRequest -Url $url -Method ([System.Net.WebRequestMethods+Ftp]::ListDirectoryDetails) `\n                              -Credential $Credential -EnableSsl $EnableSsl -PassiveMode $PassiveMode\n    $response = $request.GetResponse()\n    $stream = $response.GetResponseStream()\n    $reader = [System.IO.StreamReader]::new($stream)\n\n    while (-not $reader.EndOfStream) {\n      $line = $reader.ReadLine()\n      if ($line -match '^([d-])([rwx-]{9})\\s+\\d+\\s+\\S+\\s+\\S+\\s+(\\d+)\\s+(\\S+\\s+\\S+\\s+\\S+)\\s+(.+)$') {\n        $isDir = $Matches[1] -eq 'd'\n        $size = [long]$Matches[3]\n        $name = $Matches[5]\n\n        if ($name -eq '.' -or $name -eq '..') { continue }\n\n        $fullPath = \"$RemotePath/$name\".TrimStart('/')\n        if ($isDir -and $Recursive) {\n          $subFiles = Get-FTPFileList -BaseUrl $BaseUrl -RemotePath $fullPath -Credential $Credential `\n                                      -EnableSsl $EnableSsl -PassiveMode $PassiveMode -Recursive $true\n          foreach ($sub in $subFiles) { $null = $files.Add($sub) }\n        }\n        elseif (-not $isDir) {\n          $null = $files.Add(@{ Path = $fullPath; Size = $size; Name = $name })\n        }\n      }\n    }\n\n    $reader.Close()\n    $response.Close()\n  }\n  catch {}\n\n  return $files.ToArray()\n}\n\nfunction Get-FTPSingleFile {\n  param(\n    [string]$BaseUrl,\n    [string]$RemoteFile,\n    [string]$LocalPath,\n    [System.Net.NetworkCredential]$Credential,\n    [bool]$EnableSsl,\n    [bool]$PassiveMode\n  )\n\n  $url = \"$BaseUrl/$($RemoteFile.TrimStart('/'))\"\n  $request = New-FTPRequest -Url $url -Method ([System.Net.WebRequestMethods+Ftp]::DownloadFile) `\n                            -Credential $Credential -EnableSsl $EnableSsl -PassiveMode $PassiveMode\n\n  $response = $request.GetResponse()\n  $stream = $response.GetResponseStream()\n\n  $fileStream = [System.IO.File]::Create($LocalPath)\n  try {\n    $stream.CopyTo($fileStream)\n  }\n  finally {\n    $fileStream.Close()\n  }\n\n  $response.Close()\n\n  return (Get-Item $LocalPath).Length\n}\n\nfunction Remove-FTPFile {\n  param(\n    [string]$BaseUrl,\n    [string]$RemoteFile,\n    [System.Net.NetworkCredential]$Credential,\n    [bool]$EnableSsl,\n    [bool]$PassiveMode\n  )\n\n  $url = \"$BaseUrl/$($RemoteFile.TrimStart('/'))\"\n  $request = New-FTPRequest -Url $url -Method ([System.Net.WebRequestMethods+Ftp]::DeleteFile) `\n                            -Credential $Credential -EnableSsl $EnableSsl -PassiveMode $PassiveMode\n  $response = $request.GetResponse()\n  $response.Close()\n}\n\n#endregion\n\n#region FTPS Implicit Operations (TcpClient + SslStream)\n\nfunction Read-FTPSResponse {\n  param([System.IO.StreamReader]$Reader)\n\n  $line = $Reader.ReadLine()\n  if ($null -eq $line) { throw 'Connection closed by remote server' }\n\n  while ($line -match '^\\d{3}-') {\n    $nextLine = $Reader.ReadLine()\n    if ($null -eq $nextLine) { break }\n    $line = $nextLine\n  }\n\n  $code = 0\n  $message = $line\n  if ($line -match '^(\\d{3})\\s?(.*)') {\n    $code = [int]$Matches[1]\n    $message = $Matches[2]\n  }\n\n  return @{ Code = $code; Text = $line; Message = $message }\n}\n\nfunction New-ImplicitFTPSSession {\n  param([string]$HostName, [int]$Port, [string]$Username, [string]$Password)\n\n  $tcpClient = [System.Net.Sockets.TcpClient]::new()\n  $tcpClient.Connect($HostName, $Port)\n\n  $sslCallback = [System.Net.Security.RemoteCertificateValidationCallback]{\n    param($sender, $certificate, $chain, $sslPolicyErrors)\n    return $true\n  }\n\n  $sslStream = [System.Net.Security.SslStream]::new(\n    $tcpClient.GetStream(), $false, $sslCallback\n  )\n  $sslStream.AuthenticateAsClient($HostName)\n\n  $reader = [System.IO.StreamReader]::new($sslStream, [System.Text.Encoding]::UTF8)\n  $writer = [System.IO.StreamWriter]::new($sslStream, [System.Text.Encoding]::UTF8)\n  $writer.AutoFlush = $true\n\n  $resp = Read-FTPSResponse -Reader $reader\n  if ($resp.Code -ge 400) { throw \"Server rejected connection: $($resp.Text)\" }\n\n  $writer.WriteLine(\"USER $Username\")\n  $resp = Read-FTPSResponse -Reader $reader\n  if ($resp.Code -ge 400 -and $resp.Code -ne 331) { throw \"USER command failed: $($resp.Text)\" }\n\n  $writer.WriteLine(\"PASS $Password\")\n  $resp = Read-FTPSResponse -Reader $reader\n  if ($resp.Code -ge 400) { throw \"Authentication failed: $($resp.Text)\" }\n\n  $writer.WriteLine(\"TYPE I\")\n  $null = Read-FTPSResponse -Reader $reader\n\n  $writer.WriteLine(\"PBSZ 0\")\n  $null = Read-FTPSResponse -Reader $reader\n\n  $writer.WriteLine(\"PROT P\")\n  $null = Read-FTPSResponse -Reader $reader\n\n  return @{\n    Client    = $tcpClient\n    SslStream = $sslStream\n    Reader    = $reader\n    Writer    = $writer\n    HostName  = $HostName\n  }\n}\n\nfunction Close-ImplicitFTPSSession {\n  param([hashtable]$Session)\n\n  try { $Session.Writer.WriteLine(\"QUIT\"); $null = Read-FTPSResponse -Reader $Session.Reader } catch {}\n  try { $Session.Reader.Dispose() } catch {}\n  try { $Session.Writer.Dispose() } catch {}\n  try { $Session.SslStream.Dispose() } catch {}\n  try { $Session.Client.Dispose() } catch {}\n}\n\nfunction Open-ImplicitFTPSDataChannel {\n  param([hashtable]$Session)\n\n  $Session.Writer.WriteLine(\"PASV\")\n  $resp = Read-FTPSResponse -Reader $Session.Reader\n\n  if ($resp.Text -match '\\((\\d+),(\\d+),(\\d+),(\\d+),(\\d+),(\\d+)\\)') {\n    $dataPort = [int]$Matches[5] * 256 + [int]$Matches[6]\n  }\n  else {\n    throw \"Failed to parse PASV response: $($resp.Text)\"\n  }\n\n  $dataClient = [System.Net.Sockets.TcpClient]::new()\n  $dataClient.Connect($Session.HostName, $dataPort)\n\n  $sslCallback = [System.Net.Security.RemoteCertificateValidationCallback]{\n    param($sender, $certificate, $chain, $sslPolicyErrors)\n    return $true\n  }\n\n  $dataSsl = [System.Net.Security.SslStream]::new(\n    $dataClient.GetStream(), $false, $sslCallback\n  )\n  $dataSsl.AuthenticateAsClient($Session.HostName)\n\n  return @{ Client = $dataClient; SslStream = $dataSsl }\n}\n\nfunction Get-ImplicitFTPSFileList {\n  param([hashtable]$Session, [string]$RemotePath, [bool]$Recursive)\n\n  $files = [System.Collections.ArrayList]::new()\n  $dataChannel = Open-ImplicitFTPSDataChannel -Session $Session\n\n  try {\n    $Session.Writer.WriteLine(\"LIST $RemotePath\")\n    $resp = Read-FTPSResponse -Reader $Session.Reader\n    if ($resp.Code -ge 400) { throw \"LIST command failed: $($resp.Text)\" }\n\n    $streamReader = [System.IO.StreamReader]::new($dataChannel.SslStream, [System.Text.Encoding]::UTF8)\n    while (-not $streamReader.EndOfStream) {\n      $line = $streamReader.ReadLine()\n      if ($line -match '^([d-])([rwx-]{9})\\s+\\d+\\s+\\S+\\s+\\S+\\s+(\\d+)\\s+(\\S+\\s+\\S+\\s+\\S+)\\s+(.+)$') {\n        $isDir = $Matches[1] -eq 'd'\n        $size = [long]$Matches[3]\n        $name = $Matches[5]\n\n        if ($name -eq '.' -or $name -eq '..') { continue }\n\n        $fullPath = \"$RemotePath/$name\".TrimStart('/')\n        if ($isDir -and $Recursive) {\n          $subFiles = Get-ImplicitFTPSFileList -Session $Session -RemotePath $fullPath -Recursive $true\n          foreach ($sub in $subFiles) { $null = $files.Add($sub) }\n        }\n        elseif (-not $isDir) {\n          $null = $files.Add(@{ Path = $fullPath; Size = $size; Name = $name })\n        }\n      }\n    }\n  }\n  finally {\n    try { $dataChannel.SslStream.Close() } catch {}\n    try { $dataChannel.Client.Close() } catch {}\n  }\n\n  $null = Read-FTPSResponse -Reader $Session.Reader\n\n  return $files.ToArray()\n}\n\nfunction Get-ImplicitFTPSSingleFile {\n  param([hashtable]$Session, [string]$RemoteFile, [string]$LocalPath)\n\n  $dataChannel = Open-ImplicitFTPSDataChannel -Session $Session\n\n  try {\n    $Session.Writer.WriteLine(\"RETR $RemoteFile\")\n    $resp = Read-FTPSResponse -Reader $Session.Reader\n    if ($resp.Code -ge 400) { throw \"RETR command failed: $($resp.Text)\" }\n\n    $fileStream = [System.IO.File]::Create($LocalPath)\n    try {\n      $dataChannel.SslStream.CopyTo($fileStream)\n    }\n    finally {\n      $fileStream.Close()\n    }\n  }\n  finally {\n    try { $dataChannel.SslStream.Close() } catch {}\n    try { $dataChannel.Client.Close() } catch {}\n  }\n\n  $null = Read-FTPSResponse -Reader $Session.Reader\n\n  return (Get-Item $LocalPath).Length\n}\n\nfunction Remove-ImplicitFTPSFile {\n  param([hashtable]$Session, [string]$RemoteFile)\n\n  $Session.Writer.WriteLine(\"DELE $RemoteFile\")\n  $resp = Read-FTPSResponse -Reader $Session.Reader\n  if ($resp.Code -ge 400) { throw \"DELE command failed: $($resp.Text)\" }\n}\n\n#endregion\n\n#region SFTP Operations (Posh-SSH)\n\nfunction New-SFTPConnection {\n  param(\n    [string]$HostName,\n    [int]$Port,\n    [string]$Username,\n    [string]$Password,\n    [string]$KeyPath,\n    [string]$KeyPassphrase\n  )\n\n  $securePass = if ($KeyPath -and $KeyPassphrase) {\n    ConvertTo-SecureString $KeyPassphrase -AsPlainText -Force\n  }\n  elseif ($Password) {\n    ConvertTo-SecureString $Password -AsPlainText -Force\n  }\n  else {\n    [System.Security.SecureString]::new()\n  }\n\n  $credential = [System.Management.Automation.PSCredential]::new($Username, $securePass)\n\n  $sessionParams = @{\n    ComputerName = $HostName\n    Port         = $Port\n    Credential   = $credential\n    AcceptKey    = $true\n    Force        = $true\n    ErrorAction  = 'Stop'\n  }\n\n  if ($KeyPath) {\n    if (-not (Test-Path $KeyPath)) {\n      throw \"SSH key file not found: $KeyPath\"\n    }\n    $sessionParams['KeyFile'] = $KeyPath\n  }\n\n  $session = New-SFTPSession @sessionParams\n  return $session\n}\n\nfunction Get-SFTPFileList {\n  param([int]$SessionId, [string]$RemotePath, [bool]$Recursive)\n\n  $files = [System.Collections.ArrayList]::new()\n\n  try {\n    $items = Get-SFTPChildItem -SessionId $SessionId -Path $RemotePath -ErrorAction Stop\n\n    foreach ($item in $items) {\n      if ($item.Name -eq '.' -or $item.Name -eq '..') { continue }\n\n      if ($item.IsDirectory -and $Recursive) {\n        $subFiles = Get-SFTPFileList -SessionId $SessionId -RemotePath $item.FullName -Recursive $true\n        foreach ($sub in $subFiles) { $null = $files.Add($sub) }\n      }\n      elseif (-not $item.IsDirectory) {\n        $null = $files.Add(@{ Path = $item.FullName; Size = $item.Length; Name = $item.Name })\n      }\n    }\n  }\n  catch {}\n\n  return $files.ToArray()\n}\n\nfunction Get-SFTPSingleFile {\n  param([int]$SessionId, [string]$RemoteFile, [string]$LocalPath)\n\n  $localDir = [System.IO.Path]::GetDirectoryName($LocalPath)\n  $localFileName = [System.IO.Path]::GetFileName($LocalPath)\n  $remoteFileName = [System.IO.Path]::GetFileName($RemoteFile)\n\n  # Get-SFTPItem requires destination to be a directory\n  Get-SFTPItem -SessionId $SessionId -Path $RemoteFile -Destination $localDir -Force -ErrorAction Stop\n\n  # If downloaded filename differs from desired, rename it\n  $downloadedPath = [System.IO.Path]::Combine($localDir, $remoteFileName)\n  if ($localFileName -ne $remoteFileName) {\n    Move-Item -Path $downloadedPath -Destination $LocalPath -Force\n  }\n\n  return (Get-Item $LocalPath).Length\n}\n\nfunction Remove-SFTPFile {\n  param([int]$SessionId, [string]$RemoteFile)\n\n  Remove-SFTPItem -SessionId $SessionId -Path $RemoteFile -Force -ErrorAction Stop\n}\n\nfunction Close-SFTPConnection {\n  param([int]$SessionId)\n\n  try { Remove-SFTPSession -SessionId $SessionId -ErrorAction SilentlyContinue | Out-Null } catch {}\n}\n\n#endregion\n\n#region File Name Utilities\n\nfunction Get-UniqueFileName {\n  param([string]$FilePath)\n\n  $dir = [System.IO.Path]::GetDirectoryName($FilePath)\n  $name = [System.IO.Path]::GetFileNameWithoutExtension($FilePath)\n  $ext = [System.IO.Path]::GetExtension($FilePath)\n  $timestamp = [datetime]::Now.ToString('yyyyMMdd_HHmmss')\n\n  $newName = \"${name}_${timestamp}${ext}\"\n  return [System.IO.Path]::Combine($dir, $newName)\n}\n\nfunction Test-MatchesGlob {\n  param([string]$Path, [string]$Pattern)\n\n  $regexPattern = $Pattern.Replace('.', '\\.').Replace('*', '.*').Replace('?', '.')\n  return $Path -match \"^${regexPattern}$\"\n}\n\n#endregion\n\n#region Main Orchestrator\n\nfunction Invoke-FTPDownload {\n  param($Params, [string]$Cwd)\n\n  Write-XYProgress 0.02 'Starting FTP Download...'\n\n  # Resolve parameters with secret vault fallback\n  $protocol = (Get-Param $Params 'protocol' 'ftp').ToLower()\n\n  $ftpHost = (Get-Param $Params 'host' '').Trim()\n  if (-not $ftpHost) { $ftpHost = if ($env:FTP_HOST) { $env:FTP_HOST.Trim() } else { '' } }\n\n  $portStr = (Get-Param $Params 'port' '').ToString().Trim()\n  if (-not $portStr) { $portStr = if ($env:FTP_PORT) { $env:FTP_PORT.Trim() } else { '' } }\n\n  $username = (Get-Param $Params 'username' '').Trim()\n  if (-not $username) { $username = if ($env:FTP_USERNAME) { $env:FTP_USERNAME.Trim() } else { '' } }\n\n  $password = (Get-Param $Params 'password' '').Trim()\n  if (-not $password) { $password = if ($env:FTP_PASSWORD) { $env:FTP_PASSWORD.Trim() } else { '' } }\n\n  $ftpsMode = (Get-Param $Params 'ftpsMode' 'explicit').ToLower()\n\n  $sshKeyPath = (Get-Param $Params 'sshKeyPath' '').Trim()\n  if (-not $sshKeyPath) { $sshKeyPath = if ($env:FTP_SSH_KEY_PATH) { $env:FTP_SSH_KEY_PATH.Trim() } else { '' } }\n\n  $sshKeyPassphrase = (Get-Param $Params 'sshKeyPassphrase' '').Trim()\n  if (-not $sshKeyPassphrase) { $sshKeyPassphrase = if ($env:FTP_SSH_KEY_PASSPHRASE) { $env:FTP_SSH_KEY_PASSPHRASE.Trim() } else { '' } }\n\n  $remotePath     = (Get-Param $Params 'remotePath' '').Trim()\n  $localPath      = (Get-Param $Params 'localPath' '').Trim()\n  $downloadMode   = (Get-Param $Params 'downloadMode' 'file').ToLower()\n  $ifFileExists   = (Get-Param $Params 'ifFileExists' 'overwrite').ToLower()\n  $deleteAfter    = if ($Params.PSObject.Properties.Name -contains 'deleteAfterDownload') { [bool]$Params.deleteAfterDownload } else { $false }\n  $createLocalDirs = if ($Params.PSObject.Properties.Name -contains 'createLocalDirs') { [bool]$Params.createLocalDirs } else { $true }\n  $passiveMode    = if ($Params.PSObject.Properties.Name -contains 'passiveMode') { [bool]$Params.passiveMode } else { $true }\n\n  # Auto-detect port\n  $port = 0\n  if ($portStr -and $portStr -match '^\\d+$') {\n    $port = [int]$portStr\n  }\n  else {\n    $port = switch ($protocol) {\n      'ftp'  { 21 }\n      'ftps' { if ($ftpsMode -eq 'implicit') { 990 } else { 21 } }\n      'sftp' { 22 }\n      default { 21 }\n    }\n  }\n\n  # Determine local destination directory\n  $localDir = if ($localPath) {\n    $localPath\n  }\n  elseif ($Cwd -and (Test-Path $Cwd -PathType Container)) {\n    $Cwd\n  }\n  else {\n    (Get-Location).Path\n  }\n\n  if (-not (Test-Path $localDir -PathType Container)) {\n    if ($createLocalDirs) {\n      New-Item -Path $localDir -ItemType Directory -Force | Out-Null\n    }\n    else {\n      throw \"Local directory does not exist: $localDir\"\n    }\n  }\n\n  # Validation\n  Write-XYProgress 0.04 'Validating parameters...'\n\n  if (-not $ftpHost)    { throw 'Host is required. Provide it as a parameter or configure the FTP_HOST secret in the vault.' }\n  if (-not $username)   { throw 'Username is required. Provide it as a parameter or configure the FTP_USERNAME secret in the vault.' }\n  if (-not $remotePath) { throw 'Remote Path is required.' }\n\n  if ($protocol -eq 'sftp' -and -not $password -and -not $sshKeyPath) {\n    throw 'SFTP requires either a password or an SSH key. Provide a password or configure FTP_SSH_KEY_PATH.'\n  }\n  if ($protocol -ne 'sftp' -and -not $password) {\n    throw 'Password is required for FTP/FTPS. Provide it as a parameter or configure the FTP_PASSWORD secret in the vault.'\n  }\n\n  # Display configuration\n  $authMethod = switch ($protocol) {\n    'sftp' { if ($sshKeyPath) { \"SSH Key ($sshKeyPath)\" } else { 'Password' } }\n    default { 'Password' }\n  }\n  $protocolDesc = switch ($protocol) {\n    'ftp'  { 'FTP (Plain)' }\n    'ftps' { \"FTPS ($( ($ftpsMode.Substring(0,1).ToUpper() + $ftpsMode.Substring(1)) ) TLS)\" }\n    'sftp' { 'SFTP (SSH)' }\n  }\n  $downloadModeDesc = switch ($downloadMode) {\n    'file' { 'Single File' }\n    'folder' { 'Folder (Recursive)' }\n    'pattern' { 'Pattern Match' }\n    default { $downloadMode }\n  }\n\n  Write-XY @{ table = @{\n    title  = 'Configuration'\n    header = @('Setting', 'Value')\n    rows   = @(\n      @('Protocol', $protocolDesc),\n      @('Host', $ftpHost),\n      @('Port', $port),\n      @('Username', $username),\n      @('Auth Method', $authMethod),\n      @('Remote Path', $remotePath),\n      @('Local Path', $localDir),\n      @('Download Mode', $downloadModeDesc),\n      @('If File Exists', ($ifFileExists.Substring(0,1).ToUpper() + $ifFileExists.Substring(1))),\n      @('Delete After Download', $(if ($deleteAfter) { 'Yes' } else { 'No' })),\n      @('Passive Mode', $(if ($passiveMode) { 'Yes' } else { 'N/A (SFTP)' }))\n    )\n    caption = ''\n  } }\n\n  # Install required modules\n  Install-RequiredModules -Protocol $protocol\n\n  # Connect and download\n  $results       = [System.Collections.ArrayList]::new()\n  $totalSize     = [long]0\n  $skippedCount  = 0\n  $downloadedCount = 0\n  $ftpSession    = $null\n  $sftpSession   = $null\n  $downloadedFiles = [System.Collections.ArrayList]::new()\n\n  try {\n    Write-XYProgress 0.15 \"Connecting to ${ftpHost}:${port} via $($protocol.ToUpper())...\"\n\n    # Resolve files to download\n    $filesToDownload = [System.Collections.ArrayList]::new()\n\n    if ($protocol -eq 'sftp') {\n      $sftpSession = New-SFTPConnection -HostName $ftpHost -Port $port -Username $username `\n                                        -Password $password -KeyPath $sshKeyPath -KeyPassphrase $sshKeyPassphrase\n      $sessionId = $sftpSession.SessionId\n\n      Write-XYProgress 0.20 'Connected via SFTP'\n\n      if ($downloadMode -eq 'file') {\n        $null = $filesToDownload.Add(@{ Path = $remotePath; Name = [System.IO.Path]::GetFileName($remotePath) })\n      }\n      elseif ($downloadMode -eq 'folder') {\n        Write-XYProgress 0.22 \"Listing remote files in: $remotePath\"\n        $remoteFiles = Get-SFTPFileList -SessionId $sessionId -RemotePath $remotePath -Recursive $true\n        foreach ($file in $remoteFiles) { $null = $filesToDownload.Add($file) }\n      }\n      elseif ($downloadMode -eq 'pattern') {\n        Write-XYProgress 0.22 \"Matching remote files: $remotePath\"\n        $pathDir = [System.IO.Path]::GetDirectoryName($remotePath).Replace('\\', '/')\n        if ([string]::IsNullOrWhiteSpace($pathDir)) { $pathDir = '/' }\n        $pattern = [System.IO.Path]::GetFileName($remotePath)\n        $remoteFiles = Get-SFTPFileList -SessionId $sessionId -RemotePath $pathDir -Recursive $false\n        foreach ($file in $remoteFiles) {\n          if (Test-MatchesGlob -Path $file.Name -Pattern $pattern) {\n            $null = $filesToDownload.Add($file)\n          }\n        }\n      }\n\n      if ($filesToDownload.Count -eq 0) { throw \"No files found matching: $remotePath\" }\n\n      Write-XY @{ table = @{\n        title  = 'Files to Download'\n        header = @('#', 'File', 'Size')\n        rows   = @(\n          $filesToDownload | ForEach-Object -Begin { $i = 0 } -Process {\n            $i++\n            ,@($i, $_.Name, \"$( '{0:N0}' -f $_.Size ) bytes\")\n          }\n        )\n        caption = \"$($filesToDownload.Count) file(s) ready for download\"\n      } }\n\n      $fileIndex = 0\n      foreach ($file in $filesToDownload) {\n        $fileIndex++\n        $progress = 0.25 + (0.65 * ($fileIndex / $filesToDownload.Count))\n        $localFilePath = [System.IO.Path]::Combine($localDir, $file.Name)\n\n        Write-XYProgress $progress \"Downloading ($fileIndex/$($filesToDownload.Count)): $($file.Name)\"\n\n        if ((Test-Path $localFilePath -PathType Leaf)) {\n          if ($ifFileExists -eq 'skip') {\n            $skippedCount++\n            $null = $results.Add(@{ name = $file.Name; localPath = $localFilePath; size = $file.Size; status = 'skipped' })\n            continue\n          }\n          elseif ($ifFileExists -eq 'error') {\n            throw \"File already exists locally: $localFilePath\"\n          }\n          elseif ($ifFileExists -eq 'rename') {\n            $localFilePath = Get-UniqueFileName -FilePath $localFilePath\n          }\n        }\n\n        $downloadSize = Get-SFTPSingleFile -SessionId $sessionId -RemoteFile $file.Path -LocalPath $localFilePath\n        $totalSize += $downloadSize\n        $downloadedCount++\n        $null = $results.Add(@{ name = $file.Name; localPath = $localFilePath; size = $downloadSize; status = 'downloaded' })\n        $null = $downloadedFiles.Add([System.IO.Path]::GetFileName($localFilePath))\n\n        if ($deleteAfter) {\n          Remove-SFTPFile -SessionId $sessionId -RemoteFile $file.Path\n        }\n      }\n    }\n    elseif ($protocol -eq 'ftps' -and $ftpsMode -eq 'implicit') {\n      $ftpSession = New-ImplicitFTPSSession -HostName $ftpHost -Port $port -Username $username -Password $password\n\n      Write-XYProgress 0.20 'Connected via FTPS (Implicit TLS)'\n\n      if ($downloadMode -eq 'file') {\n        $null = $filesToDownload.Add(@{ Path = $remotePath; Name = [System.IO.Path]::GetFileName($remotePath) })\n      }\n      elseif ($downloadMode -eq 'folder') {\n        Write-XYProgress 0.22 \"Listing remote files in: $remotePath\"\n        $remoteFiles = Get-ImplicitFTPSFileList -Session $ftpSession -RemotePath $remotePath -Recursive $true\n        foreach ($file in $remoteFiles) { $null = $filesToDownload.Add($file) }\n      }\n      elseif ($downloadMode -eq 'pattern') {\n        Write-XYProgress 0.22 \"Matching remote files: $remotePath\"\n        $pathDir = [System.IO.Path]::GetDirectoryName($remotePath).Replace('\\', '/')\n        if ([string]::IsNullOrWhiteSpace($pathDir)) { $pathDir = '/' }\n        $pattern = [System.IO.Path]::GetFileName($remotePath)\n        $remoteFiles = Get-ImplicitFTPSFileList -Session $ftpSession -RemotePath $pathDir -Recursive $false\n        foreach ($file in $remoteFiles) {\n          if (Test-MatchesGlob -Path $file.Name -Pattern $pattern) {\n            $null = $filesToDownload.Add($file)\n          }\n        }\n      }\n\n      if ($filesToDownload.Count -eq 0) { throw \"No files found matching: $remotePath\" }\n\n      Write-XY @{ table = @{\n        title  = 'Files to Download'\n        header = @('#', 'File', 'Size')\n        rows   = @(\n          $filesToDownload | ForEach-Object -Begin { $i = 0 } -Process {\n            $i++\n            ,@($i, $_.Name, \"$( '{0:N0}' -f $_.Size ) bytes\")\n          }\n        )\n        caption = \"$($filesToDownload.Count) file(s) ready for download\"\n      } }\n\n      $fileIndex = 0\n      foreach ($file in $filesToDownload) {\n        $fileIndex++\n        $progress = 0.25 + (0.65 * ($fileIndex / $filesToDownload.Count))\n        $localFilePath = [System.IO.Path]::Combine($localDir, $file.Name)\n\n        Write-XYProgress $progress \"Downloading ($fileIndex/$($filesToDownload.Count)): $($file.Name)\"\n\n        if ((Test-Path $localFilePath -PathType Leaf)) {\n          if ($ifFileExists -eq 'skip') {\n            $skippedCount++\n            $null = $results.Add(@{ name = $file.Name; localPath = $localFilePath; size = $file.Size; status = 'skipped' })\n            continue\n          }\n          elseif ($ifFileExists -eq 'error') {\n            throw \"File already exists locally: $localFilePath\"\n          }\n          elseif ($ifFileExists -eq 'rename') {\n            $localFilePath = Get-UniqueFileName -FilePath $localFilePath\n          }\n        }\n\n        $downloadSize = Get-ImplicitFTPSSingleFile -Session $ftpSession -RemoteFile $file.Path -LocalPath $localFilePath\n        $totalSize += $downloadSize\n        $downloadedCount++\n        $null = $results.Add(@{ name = $file.Name; localPath = $localFilePath; size = $downloadSize; status = 'downloaded' })\n        $null = $downloadedFiles.Add([System.IO.Path]::GetFileName($localFilePath))\n\n        if ($deleteAfter) {\n          Remove-ImplicitFTPSFile -Session $ftpSession -RemoteFile $file.Path\n        }\n      }\n    }\n    else {\n      # FTP / FTPS Explicit\n      $enableSsl  = ($protocol -eq 'ftps')\n      $credential = [System.Net.NetworkCredential]::new($username, $password)\n      $baseUrl    = Get-FTPBaseUrl -HostName $ftpHost -Port $port\n\n      Write-XYProgress 0.20 \"Connected via $($protocol.ToUpper())$(if ($enableSsl) { ' (Explicit TLS)' } else { '' })\"\n\n      if ($downloadMode -eq 'file') {\n        $null = $filesToDownload.Add(@{ Path = $remotePath; Name = [System.IO.Path]::GetFileName($remotePath) })\n      }\n      elseif ($downloadMode -eq 'folder') {\n        Write-XYProgress 0.22 \"Listing remote files in: $remotePath\"\n        $remoteFiles = Get-FTPFileList -BaseUrl $baseUrl -RemotePath $remotePath -Credential $credential `\n                                       -EnableSsl $enableSsl -PassiveMode $passiveMode -Recursive $true\n        foreach ($file in $remoteFiles) { $null = $filesToDownload.Add($file) }\n      }\n      elseif ($downloadMode -eq 'pattern') {\n        Write-XYProgress 0.22 \"Matching remote files: $remotePath\"\n        $pathDir = [System.IO.Path]::GetDirectoryName($remotePath).Replace('\\', '/')\n        if ([string]::IsNullOrWhiteSpace($pathDir)) { $pathDir = '/' }\n        $pattern = [System.IO.Path]::GetFileName($remotePath)\n        $remoteFiles = Get-FTPFileList -BaseUrl $baseUrl -RemotePath $pathDir -Credential $credential `\n                                       -EnableSsl $enableSsl -PassiveMode $passiveMode -Recursive $false\n        foreach ($file in $remoteFiles) {\n          if (Test-MatchesGlob -Path $file.Name -Pattern $pattern) {\n            $null = $filesToDownload.Add($file)\n          }\n        }\n      }\n\n      if ($filesToDownload.Count -eq 0) { throw \"No files found matching: $remotePath\" }\n\n      Write-XY @{ table = @{\n        title  = 'Files to Download'\n        header = @('#', 'File', 'Size')\n        rows   = @(\n          $filesToDownload | ForEach-Object -Begin { $i = 0 } -Process {\n            $i++\n            ,@($i, $_.Name, \"$( '{0:N0}' -f $_.Size ) bytes\")\n          }\n        )\n        caption = \"$($filesToDownload.Count) file(s) ready for download\"\n      } }\n\n      $fileIndex = 0\n      foreach ($file in $filesToDownload) {\n        $fileIndex++\n        $progress = 0.25 + (0.65 * ($fileIndex / $filesToDownload.Count))\n        $localFilePath = [System.IO.Path]::Combine($localDir, $file.Name)\n\n        Write-XYProgress $progress \"Downloading ($fileIndex/$($filesToDownload.Count)): $($file.Name)\"\n\n        if ((Test-Path $localFilePath -PathType Leaf)) {\n          if ($ifFileExists -eq 'skip') {\n            $skippedCount++\n            $null = $results.Add(@{ name = $file.Name; localPath = $localFilePath; size = $file.Size; status = 'skipped' })\n            continue\n          }\n          elseif ($ifFileExists -eq 'error') {\n            throw \"File already exists locally: $localFilePath\"\n          }\n          elseif ($ifFileExists -eq 'rename') {\n            $localFilePath = Get-UniqueFileName -FilePath $localFilePath\n          }\n        }\n\n        $downloadSize = Get-FTPSingleFile -BaseUrl $baseUrl -RemoteFile $file.Path -LocalPath $localFilePath `\n                                         -Credential $credential -EnableSsl $enableSsl -PassiveMode $passiveMode\n        $totalSize += $downloadSize\n        $downloadedCount++\n        $null = $results.Add(@{ name = $file.Name; localPath = $localFilePath; size = $downloadSize; status = 'downloaded' })\n        $null = $downloadedFiles.Add([System.IO.Path]::GetFileName($localFilePath))\n\n        if ($deleteAfter) {\n          Remove-FTPFile -BaseUrl $baseUrl -RemoteFile $file.Path -Credential $credential `\n                         -EnableSsl $enableSsl -PassiveMode $passiveMode\n        }\n      }\n    }\n\n    # Display results\n    Write-XYProgress 0.95 'Download complete'\n\n    $resultRows = @($results | ForEach-Object -Begin { $i = 0 } -Process {\n      $i++\n      $statusIcon = switch ($_.status) { 'downloaded' { 'Downloaded' }; 'skipped' { 'Skipped' }; default { $_.status } }\n      ,@($i, $_.name, \"$( '{0:N0}' -f $_.size ) bytes\", $statusIcon)\n    })\n\n    Write-XY @{ table = @{\n      title   = 'Download Results'\n      header  = @('#', 'File', 'Size', 'Status')\n      rows    = $resultRows\n      caption = \"$downloadedCount downloaded, $skippedCount skipped, $( '{0:N0}' -f $totalSize ) bytes total\"\n    } }\n\n    # Build output data\n    return [pscustomobject]@{\n      tool           = 'ftpDownload'\n      success        = $true\n      protocol       = $protocol\n      host           = $ftpHost\n      port           = $port\n      remotePath     = $remotePath\n      localPath      = $localDir\n      files          = @($results)\n      downloadedFiles = @($downloadedFiles.ToArray())\n      totalFiles     = $downloadedCount\n      totalSize      = $totalSize\n      skippedFiles   = $skippedCount\n      deletedRemote  = $deleteAfter\n      timestamp      = [datetime]::UtcNow.ToString('o')\n    }\n  }\n  catch {\n    $phase = switch -Regex ($_.Exception.Message) {\n      'resolv|DNS|refused|timeout|unreachable|connect' { 'Connection'; break }\n      'auth|login|credential|key.*invalid|passphrase'  { 'Authentication'; break }\n      'permission|denied|550|553'                      { 'Permission'; break }\n      'SSL|TLS|certificate|handshake'                  { 'Protocol'; break }\n      default                                          { 'Transfer' }\n    }\n\n    $errorMsg = Format-TransferError -ErrorRecord $_ -Phase $phase -Protocol $protocol\n    throw $errorMsg\n  }\n  finally {\n    if ($ftpSession)  { Close-ImplicitFTPSSession -Session $ftpSession }\n    if ($sftpSession) { Close-SFTPConnection -SessionId $sftpSession.SessionId }\n  }\n}\n\n#endregion\n\n#region Main Entry Point\n\ntry {\n  $job    = Read-JobFromStdin\n  $Params = $job.params\n\n  $Cwd = if ($job.PSObject.Properties.Name -contains 'cwd') { $job.cwd } else { $null }\n\n  if ($Cwd -and (Test-Path $Cwd -PathType Container)) { Set-Location $Cwd }\n\n  $result = Invoke-FTPDownload -Params $Params -Cwd $Cwd\n  Write-XYSuccess -Data $result -Files $result.downloadedFiles -Description \"Downloaded $($result.totalFiles) file(s) via $($result.protocol.ToUpper()) from $($result.host)\"\n  exit 0\n}\ncatch {\n  Write-XYError -Code 1 -Description $_.Exception.Message\n  exit 1\n}\n\n#endregion",
				"kill": "none",
				"runner": false
			}
		}
	]
}
